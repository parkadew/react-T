
리액트 훅 함수
: 라이프사이클(생명주기) --> 웹 
 
 리엑트의 훅 함수
 : 라이프사이클(생명주기) ---> 웹 페이지가 시작되었을 때부터 끝날 때까지 일어나는 이벤트 등을 다루기 위함
 : React 16.8보다 이전 버전 세대인 클래스형 컴포넌트에서 사용하던 말 --> 함수의 형태가 아니었음
 : meta팀에서 고민 --> 사용법이 너무 어려운데? 우리 이거 함수형으로 바꿀까 --> 함수형 컴포넌트(16.8.0)
 : 클래스 컴포넌트가 갖고 있던 라이프 사이클이라고 하는 것을 함수형 컴포넌트에서도 사용할 수 있도록 한 것이 훅 함수

 ===> 함수형 컴포넌트에서 컴포넌트가 사용자에게 보일 때부터 보이지 않을 때까지 발생할 수 있는 이벤트를 다루는 함수
 (마운트 -> 언마운트)

 ********** 1. useState *********
 리엑트의 상태를 관리하는 함수, 상태를 생성하고 값을 변경할 수 있습니다.

 ** 상태 **
    리엑트는 DOM API를 사용하나요? 사용할 수는 있지만 지양하고 있습니다.
    돔을 활용하지 않고 가상돔을 활용하다보니 값은 변경 되었지만 사용자가 보는 화면은 변경되지 않습니다.
    단, 리엑트에서는 개발자가 화면을 다시 그리고 싶을 때 화면을 다시 그릴 수 있어요

    상태란, 리엑트에서 가상돔과 실제 사용자들이 보는 렌더트리의 돔을 동기화할 수 있는 캐싱(저장)되어있는 값
    리엑트는 differ 알고리즘을 통해 이전 컴포넌트의 상태와 현재 컴포넌트의 상태를 비교하여 만약 상태가 변경되었다면
    변경이 된 함수만 다시 리랜더링 합니다.

    ==> 컴포넌트 내의 상태(변수 --> 리엑트가 리랜더를 위해 만든 변수)가 바뀌면 컴포넌트를 다시 그린다.

    주의사항 ---> 상태는 남발해서는 된다 안된다? --> (저장) -- 코스트가 필요한 일이죠
    불필요히 화면을 다시 그릴 수 있기 때문에 상태는 늘 (최소화!!!)

    ex)
    const [state, setState] = useState()
          ----- 변수명(이름 내 마음대로)
                  -------- set변수명
    
    상태의 특징
    값을 마음대로 바꾸지(재할당) 못합니다.
    state = 4 => X

    상태는 반드시 setState 함수로만 변경이 가능합니다.
    setState(4) => O

    --> 이거 사용하는 순간 이전 값이랑 다르다면 컴포넌트 리랜더링 합니다.

    ** 불변성 **
    let a = 5;
    a = 4;

    a는 5를 제거하고 4를 재할당

    ------------------------------

    const object = {
        a: 4
    }
    object.a = 5;
    object는 a를 제거하고 다시 할당할까요? 값을 바꿀까요? --> 값을 바꿉니다
    값을 바꾸는게 문제가 되는건 아니에요

    "리엑트"에서는 문제가 됩니다. 
    상태는 이전 값과 이후 값을 (비교)
    객체의 값은 참조 주소일까요 값일까요 --> 주소

    그래서 복사본을 만들고 할당을 다시 해줘야만 상태가 변경됩니다.
    불변성을 지켜야한다 --> 새로 할당 되어야한다

    ex)
        const temp_object = {...object}
        setState(temp_object)

    ** map, filter
    => 이 친구들의 반환값 --> "새로운 배열" --> 사용한 것만으로 복사본이 생성

    ------------------------------


2. useRef
   초기화가 안되면 안될까??
    "리랜더링이 함수를 다시 실행하는 것이다"

    function a(){
        let b = 5;
        b++;
    }

    a() // b = 6;
    a() // b = 6;

    function Component(){
        const [forceRender, setForceRender] = useState(false)
        let b = 5;
        b++;


        return <div>{b}
            <button onClick={() => b++}>+</button>
                                // true -> false
                                // false -> true
            <button onClick{()=> setForceRender(!forceRender)}> 리랜더 </button>
        </div>
    }

    --> 화면에 뭐가 보이죠? 6
    --> + 버튼을 세번 눌렀습니다 화면에 뭐가 보일까요? b의 값은 9이지만, 6이 보일 것
    --> + 버튼을 세번 누르고 리랜더 버튼을 누르면 화면에 뭐가 보일까요? b의 값이 6이기 때문에 6
    --> 이게 내가 의도한건가요? 나는 9가 화면에 나왔으면 좋겠어서 + 버튼을 3번 누르거잖아, 근데 리랜더 될 때마다 변수가 초기화??!?!?

    --> 저번시간에 한것과 무슨 차이가 있는거지..?
   
    useRef는 리랜더링과 상관없이 변수의 값을 유지하는 변수

    function Component(){
        const [forceRender, setForceRender] = useState(false)
        const b = useRef(5)
        // 리랜더링이 되어도 값을 다시 선언하지 않고 계속 유지한다

        b.current++;
        // 값에 접근할려면 current 속성에 접근해야함

        return <div> 
            {b.current}
            <button onClick={() => b.current++}> + <button>
            <button onClick={() => setForceRender(!forceRender)} 리랜더 </button>
            {가설 - usestate의 setForceRender를 실행시켜야지만이 화면의 값이 리렌더링 되어 보이는것?}
        </div>
    }

    --> console.log(b) // { current: 6 } // console.log(b.current) // 6
    --> + 버튼을 3번 눌렀을 때 화면에 보이는 b.current의 값은? // b.current 값 자체는 9이지만, 화면에 보이는 것은 6입니다
        // 그럼 대체 언제 화면에 9가보일수있는건데
        // useRef !== state
    --> + 버튼을 3번 눌렀을 때 리랜더 버튼을 누르면 화면에 보이는 값은? // 10 --> 연산 조심(리랜더링이 되면 연산도 다시한다, ++를 다시한 것)


    결론
        useRef는 상태가 변경됨에 따라 리랜더링 할 때 변수의 선언을 다시하여 초기화되는데, 
        이러한 과정을 거치지 않고 값을 유지하고 있는 변수

    이러한 특징 때문에, DOM에 접근할 때도 사용할 수 있다
    리엑트에 돔이 반드시 접근하는 경우는 있어요 --> "지양한다"

    return <div className ="seongyong" />
    document.querySelector(".seongyong").style.color = "red" // 폰트 컬러 --> 리랜더링 하지 않아도 실제 돔에 접근했기 때문에 수정됨

        개발자 도구로 확인하면 <div style='color=red'/>
        리랜더링 되면 <div className ="seongyong" />

    ++ 리랜더링이 발생하면 이 값이 유지될까요? -> 안돼요
    --> 아 DOM-API 최대한 줄일게요

    그런데 여러분들이 반드시 사용해야하는 경우는 있어요
    input의 value를 가지고 올 때

    이때 useRef의 특성을 이용하여 값을 유지시킬 수 있기 때문에 돔에 접근할 수 있습니다.

        const inputRef = useRef()
        <input defaultValue={"123"} ref={inputRef} />

        inputRef.current.value = '' // 반드시 접근해야하는 경우가 생김
        inputRef.current.style.color = 'red'

    >> 이게 가능한 이유는, 리랜더링 되어도 값을 갖고 있기 때문이다.
    >> 따라서 리엑트는 리랜더링 되었을 때 DOM에 대한 정보가 초기화 되기 때문에 DOM 사용을 지양하는 것, 사용이 불가한 것이 아님

 3. useEffect

        외부 효과(사이드 이펙트)
        페이지의 생명주기 동안 발생할 수 있는 외부 효과를 다룰 수 있는 훅 함수
        => 나는 a 함수를 실행했을 뿐인데 // 특정 로직이 같이 실행된다!(외부 효과)

        * 페이지가 마운트 되었을 때
        * 페이지가 언마운트 되었을 때
        * 특정 상태가 바뀌었을 때 : 상태 바뀌고 나서 바로 출력하는 것이 안됩니다

    -------------

 4. useMemo
    function Component(){
        let a = 5 + 3; // 8
        const a = useMemo(() => 5+3, [])

        // 연산 -> 리랜더링을 되었을 때 a는 8이 그대로
        // 5 + 3을 다시 굳이 할 필요가 있을까요?
        // useRef 처럼 값을 리랜더링해도 저장하기 위해서 사용하는데
        // useMemo는 연산의 결과값을 저장

        // 연산이 오래걸리는 결과 리랜더링을 해도 같다면, 저장하고 사용하는 것이
        // 훨씬 리랜더링 속도가 빠르지 않겠어요?

        // 리랜더링 되어도 5+3을 실행하지 않는다
        // 결과 값이 8이 저장되어있음

        // 연산이 되는 시간을 줄이기위해 사용하는 것, 리랜더링 되어도 결과가 같으니까
        
        return <div> :) </div>
    }

 5. useCallback

    변수도 리랜더링이 되면 다시 선언 돼
    연산도 리랜더링이 되면 다새 연산 해
    함수도 리랜더링이 되면 다시 선언할까요 안할까요? -> 다시 선언합니다.

    useCallback은 리랜더링 되어도 함수의 로직이 같다면 다시 선언할 필요가 없죠

    function Component() {

        const calculate = useCallback(() => {
            return 5 + 3 // 결과 값이 같기 때문에 다시 선언할 필요가 없습니다
        }, [])

        return <div>{calculate()}</div>
    }

    -------------

    박관형님
    권명순님
    김준석님
    박상진님
    박영준님
    박희정님
    정호준님
    최다윤님
    현지원님